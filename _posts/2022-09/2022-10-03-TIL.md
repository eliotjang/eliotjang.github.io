---
title: "[TIL] 불리언 / 부동소수점"
excerpt: "Today I Learned"

toc: true
toc_sticky: true

header:
  teaser: /assets/images_v2/TIL/Today-I-Learned.jpg

categories:
  - TIL
tags:
  - TIL

last_modified_at: 2022-10-02T22:10:00+09:00
---
![](https://eliotjang.github.io/assets/images_v2/TIL/Today-I-Learned.jpg){: width="50%" height="50%"}

# Today I Learned

## 불리언  

불리언의 자료형은 bool이다.  
사실 bool은 그냥 1byte 정수에 불과하다.  
그러나 참 혹은 거짓 둘 중 하나라는 것을 알기 때문에 가독성이 좋아서 자주 사용한다.  

그렇다면 참 혹은 거짓만 구별하기 위해선 0과 1을 표현할 수 있는 1bit만으로도 표현할 수 있는데 왜 1byte 정수로 잡았을까?  
모든 프로그래밍 언어에서 최소 단위는 1byte이다.  
심지어 어셈블리어 언어에서도 최소 단위가 1byte이다.  
결론은 1byte보다 작은 정수를 표현하는 자료형은 없다.  

1bit도 만들면 되지 않나라는 생각이 들긴 하지만 자료형의 자존심 같은 걸까? 일단 그렇게 생각하자.  

## 부동소수점  

실수의 자료형은 float과 double이다.  
c++에서 실수는 기본적으로 double로 잡혀있다.  
만약 float를 사용하려면 실수 끝에 f를 붙여줘야만 한다.  

컴퓨터에서 실수를 표현하는 방법은 어떻게 될까?  
직관적으로 생각했을 땐 상위 바이트와 하위 바이트를 나눠서 소수점 좌우를 나타내는것이 좋아보인다.  
그러나 그렇게되면 표현할 수 있는 숫자가 그리 많지 않다.  
float로 예를 들면 4바이트이기 때문에 소수점 좌측과 우측 모두 0 ~ 65535까지밖에 표현할 수 없다.
최대가 65535.65535이다.  
결론은 좋은 방법이 아니다.  

그래서 부동소수점을 활용해야한다.  
여기서 **부**는 **아닐 부**가 아니라 **뜰 부**를 뜻한다.  
한마디로 소수점이 둥둥 떠다닌다는 의미다.  

**방법은 2진수 변환 → 정규화 → 부호/지수/유효숫자로 구분한다.**  

- float는 부호 1bit, 지수 8bit, 유효숫자 23bit로 표현
- double은 부호 1bit, 지수 11bit, 유효숫자 53bit로 표현  

-3.375를 예로 들어보자.(float)  

먼저, 2진수로 변환하자.  
3은 0b11로 표현할 수 있고,  
0.375는 0.5 * 0 + 0.25 * 1 + 0.125 * 1이므로 0b0.0111로 표현할 수 있다.  
그래서 3.375는 0b11.0111로 변환된다.  

다음, 정규화하자.  
0b11.011을 정규화시키면 0b1.1011 * 2가 나온다.  
결국 부호는 1, 지수는 1, 유효숫자는 1011이다.  
단, 지수는 unsigned byte라고 가정하고 나온 숫자 + 127을 해줘야한다.  
현재 지수가 1이므로 128을 만들어줘야 하니, 0b10000000으로 표현 가능하다.  

그래서 결론은 부호 / 지수 / 유효숫자로 표현해야하니,  
0b 1 100'0000'0 101'0000'0000'0000'0000이 나온다.  

실제로 컴퓨터가 어떻게 계산했는지 확인하려면,  
1. Visual Stuio를 켜서 코드를 친 다음, 디버그로 들어간다.  
2. 변수를 조사식에 넣어서 계산하고자 하는 숫자가 나오는지 확인하고,  
3. &변수를 조사식에 넣어서 변수의 주소값을 확인한다.  
4. 메모리에 변수의 주소값을 넣고 입력한다.  
5. 상위 4바이트를 확인해서 숫자가 일치한지 보면된다.  
  - 참고로 리틀 엔디안 방식이므로 숫자를 뒤집어서 확인해야한다.  
